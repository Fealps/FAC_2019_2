.data
str_erro_tam: .asciiz "Entradas invalidas.\n"
str_erro_prim: .asciiz " O modulo nao eh primo.\n"
str_msg_1: .asciiz "A exponencial modular "
str_msg_2: .asciiz " elevado a "
str_msg_3: .asciiz " (mod "
str_msg_4: .asciiz ") eh "
str_msg_5: .asciiz "."

.text
.globl main

main:

ler_inteiro:
	li $v0, 5 # ler inteiro
	syscall 
	move $s3, $v0 #base
	
	li $v0, 5 # ler inteiro
	syscall
	move $s2, $v0 #expoente
	
	li $v0, 5 # ler inteiro
	syscall
	move $s1, $v0 #primo
	
	bge $s3, 65536,erro_tam #if(a3 >= 65536)
	bge $s2, 65536,erro_tam #if(a2 >= 65536)
	bge $s1, 65536,erro_tam #if(a1 >= 65536)
	blez $s3, erro_tam 	#if(a3 < 0)
	blez $s2, erro_tam	#if(a2 < 0)
	blez $s1, erro_tam	#if(a1 < 0)

	addi	$t0, $zero, 2				# int x = 2
	jal eh_primo_test
	#if(is_prime(a0))
	
	j calc_exp
	

erro_tam:
	la $a0, str_erro_tam #print de error
	li $v0, 4
	syscall
	j exit

eh_primo_test:
	slt	$t1, $t0, $s1				# if (x > num)
	bne	$t1, $zero, eh_primo_loop		
	addi	$v0, $zero, 1				# eh primo
	jr	$ra						# return 1

eh_primo_loop:						# else
	div	$s1, $t0					
	mfhi	$t3						# c = (num % x)
	slti	$t4, $t3, 1				
	beq	$t4, $zero, eh_primo_loop_continue	# if (c == 0)
	j erro_prime						#vai para erro primo

eh_primo_loop_continue:		
	addi $t0, $t0, 1				# x++
	j	eh_primo_test				# continua o loop


erro_prime:
	la $a0, str_erro_prim #print de error
	li $v0, 4
	syscall
	j exit

calc_exp:
	beq $s2, 1, exp_eh_um # if (exp = 1)
	addi $t0, $zero, 2 # temp = 2
	div $s2, $t0 # exp/2
	mflo $t0 # temp = exp/2
	addu $s4, $zero, $s3 # resultado = base
	mfhi $t0 # quociente = exp (mod 2) = multiplos de 2 no exponente
	mfhi $t1 # resto = exp (mod 2)  
	j exp_eh_par
	

exp_eh_par:
	mult $s4, $s4 # base^2
	mflo $s4 # resultado = base^2
	subu $t0, $t0, 1 # quociente--
	bgtz $t0, exp_eh_par # while(quociente > 0)
	beq $t1, 1, exp_eh_impar # se resto = 1 exponente eh impar
	j imprime_saida

exp_eh_impar:
	addu $s4, $s4, $s3 # resultado = resultado * base^1
	j imprime_saida
	
exp_eh_um:
	addu $s4, $zero, $s3 # resultado = base^1 = base
	j imprime_saida
	
imprime_saida:
	div $s4, $s1 # base / primo
	mfhi $s4 # resultado = base (mod primo)
	
	la $a0, str_msg_1 # string de resultado
	li $v0, 4
	syscall
		
	move $a0, $s3  # print base
	li $v0, 1
	syscall
		
	la $a0, str_msg_2 # string de resultado
	li $v0, 4
	syscall
	
	move $a0, $s2 # print expoente
	li $v0, 1
	syscall
	
	la $a0, str_msg_3 # string de resultado
	li $v0, 4
	syscall
	
	move $a0, $s1  # print primo
	li $v0, 1
	syscall
	 
	la $a0, str_msg_4 # string de resultado
	li $v0, 4
	syscall
	
	move $a0, $s4 # print resultado
	li $v0, 1
	syscall
	
	la $a0, str_msg_5 # string de resultado
	li $v0, 4
	syscall
	
	j exit
exit:
	li $v0, 10
	syscall
